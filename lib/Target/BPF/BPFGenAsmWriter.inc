/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void BPFInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const uint32_t OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    443U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    436U,	// BUNDLE
    453U,	// LIFETIME_START
    423U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    641U,	// ADD_ri
    583U,	// ADD_rr
    2930U,	// ADJCALLSTACKDOWN
    5014U,	// ADJCALLSTACKUP
    647U,	// AND_ri
    593U,	// AND_rr
    2602U,	// BSWAP16
    2569U,	// BSWAP32
    2593U,	// BSWAP64
    715U,	// DIV_ri
    784U,	// DIV_rr
    2769U,	// JAL
    17074U,	// JEQ_ri
    17147U,	// JEQ_rr
    2801U,	// JMP
    17050U,	// JNE_ri
    16998U,	// JNE_rr
    17043U,	// JSGE_ri
    16992U,	// JSGE_rr
    17092U,	// JSGT_ri
    17162U,	// JSGT_rr
    17037U,	// JUGE_ri
    16987U,	// JUGE_rr
    17086U,	// JUGT_ri
    17157U,	// JUGT_rr
    98872U,	// LDB
    98892U,	// LDD
    98923U,	// LDH
    99098U,	// LDW
    6961U,	// LD_ABS_B
    6987U,	// LD_ABS_H
    7013U,	// LD_ABS_W
    6948U,	// LD_IND_B
    6974U,	// LD_IND_H
    7000U,	// LD_IND_W
    49682U,	// LD_imm64
    148198U,	// LD_pseudo
    82709U,	// MOV_ri
    82709U,	// MOV_rr
    684U,	// MUL_ri
    737U,	// MUL_rr
    2806U,	// NOP
    697U,	// OR_ri
    769U,	// OR_rr
    468U,	// RET
    672U,	// SLL_ri
    727U,	// SLL_rr
    629U,	// SRA_ri
    563U,	// SRA_rr
    678U,	// SRL_ri
    732U,	// SRL_rr
    1085U,	// STB
    1110U,	// STD
    1136U,	// STH
    1311U,	// STW
    635U,	// SUB_ri
    578U,	// SUB_rr
    9093U,	// Select
    426497U,	// XADD32
    426521U,	// XADD64
    696U,	// XOR_ri
    768U,	// XOR_rr
    0U
  };

  static const char AsmStrs[] = {
  /* 0 */ 'x', 'a', 'd', 'd', '3', '2', 9, 0,
  /* 8 */ 'b', 's', 'w', 'a', 'p', '3', '2', 9, 0,
  /* 17 */ 'l', 'd', '_', '6', '4', 9, 0,
  /* 24 */ 'x', 'a', 'd', 'd', '6', '4', 9, 0,
  /* 32 */ 'b', 's', 'w', 'a', 'p', '6', '4', 9, 0,
  /* 41 */ 'b', 's', 'w', 'a', 'p', '1', '6', 9, 0,
  /* 50 */ 's', 'r', 'a', 9, 0,
  /* 55 */ 'l', 'd', 'b', 9, 0,
  /* 60 */ 's', 't', 'b', 9, 0,
  /* 65 */ 's', 'u', 'b', 9, 0,
  /* 70 */ 'a', 'd', 'd', 9, 0,
  /* 75 */ 'l', 'd', 'd', 9, 0,
  /* 80 */ 'a', 'n', 'd', 9, 0,
  /* 85 */ 's', 't', 'd', 9, 0,
  /* 90 */ 'j', 'g', 'e', 9, 0,
  /* 95 */ 'j', 's', 'g', 'e', 9, 0,
  /* 101 */ 'j', 'n', 'e', 9, 0,
  /* 106 */ 'l', 'd', 'h', 9, 0,
  /* 111 */ 's', 't', 'h', 9, 0,
  /* 116 */ 's', 'r', 'a', 'i', 9, 0,
  /* 122 */ 's', 'u', 'b', 'i', 9, 0,
  /* 128 */ 'a', 'd', 'd', 'i', 9, 0,
  /* 134 */ 'a', 'n', 'd', 'i', 9, 0,
  /* 140 */ 'j', 'g', 'e', 'i', 9, 0,
  /* 146 */ 'j', 's', 'g', 'e', 'i', 9, 0,
  /* 153 */ 'j', 'n', 'e', 'i', 9, 0,
  /* 159 */ 's', 'l', 'l', 'i', 9, 0,
  /* 165 */ 's', 'r', 'l', 'i', 9, 0,
  /* 171 */ 'm', 'u', 'l', 'i', 9, 0,
  /* 177 */ 'j', 'e', 'q', 'i', 9, 0,
  /* 183 */ 'x', 'o', 'r', 'i', 9, 0,
  /* 189 */ 'j', 'g', 't', 'i', 9, 0,
  /* 195 */ 'j', 's', 'g', 't', 'i', 9, 0,
  /* 202 */ 'd', 'i', 'v', 'i', 9, 0,
  /* 208 */ 'c', 'a', 'l', 'l', 9, 0,
  /* 214 */ 's', 'l', 'l', 9, 0,
  /* 219 */ 's', 'r', 'l', 9, 0,
  /* 224 */ 'm', 'u', 'l', 9, 0,
  /* 229 */ 'l', 'd', '_', 'p', 's', 'e', 'u', 'd', 'o', 9, 0,
  /* 240 */ 'j', 'm', 'p', 9, 0,
  /* 245 */ 'n', 'o', 'p', 9, 0,
  /* 250 */ 'j', 'e', 'q', 9, 0,
  /* 255 */ 'x', 'o', 'r', 9, 0,
  /* 260 */ 'j', 'g', 't', 9, 0,
  /* 265 */ 'j', 's', 'g', 't', 9, 0,
  /* 271 */ 'd', 'i', 'v', 9, 0,
  /* 276 */ 'm', 'o', 'v', 9, 0,
  /* 281 */ 'l', 'd', 'w', 9, 0,
  /* 286 */ 's', 't', 'w', 9, 0,
  /* 291 */ 'l', 'd', 'i', 'n', 'd', '_', 'b', 9, 'r', '0', ',', 32, 0,
  /* 304 */ 'l', 'd', 'a', 'b', 's', '_', 'b', 9, 'r', '0', ',', 32, 0,
  /* 317 */ 'l', 'd', 'i', 'n', 'd', '_', 'h', 9, 'r', '0', ',', 32, 0,
  /* 330 */ 'l', 'd', 'a', 'b', 's', '_', 'h', 9, 'r', '0', ',', 32, 0,
  /* 343 */ 'l', 'd', 'i', 'n', 'd', '_', 'w', 9, 'r', '0', ',', 32, 0,
  /* 356 */ 'l', 'd', 'a', 'b', 's', '_', 'w', 9, 'r', '0', ',', 32, 0,
  /* 369 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 388 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', 32, 'P', 'S', 'E', 'U', 'D', 'O', 32, 0,
  /* 405 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 422 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 435 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 442 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 452 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 467 */ 'r', 'e', 't', 0,
  };

  O << "\t";

  // Emit the opcode for the instruction.
  uint32_t Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511)-1;


  // Fragment 0 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 9) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, RET
    return;
    break;
  case 1:
    // ADD_ri, ADD_rr, ADJCALLSTACKDOWN, ADJCALLSTACKUP, AND_ri, AND_rr, BSWA...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // STB, STD, STH, STW
    printMemOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 11) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr, AND_ri, AND_rr, DIV_ri, DIV_rr, JEQ_ri, JEQ_rr, JNE_ri...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN, BSWAP16, BSWAP32, BSWAP64, JAL, JMP, NOP
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << ' '; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // LD_ABS_B, LD_ABS_H, LD_ABS_W, LD_IND_B, LD_IND_H, LD_IND_W
    O << ".data + "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 4:
    // Select
    O << " = "; 
    printOperand(MI, 1, O); 
    O << ' '; 
    printOperand(MI, 3, O); 
    O << ' '; 
    printOperand(MI, 2, O); 
    O << " ? "; 
    printOperand(MI, 4, O); 
    O << " : "; 
    printOperand(MI, 5, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 14) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr, AND_ri, AND_rr, DIV_ri, DIV_rr, MUL_ri, MUL_rr, OR_ri,...
    printOperand(MI, 2, O); 
    return;
    break;
  case 1:
    // JEQ_ri, JEQ_rr, JNE_ri, JNE_rr, JSGE_ri, JSGE_rr, JSGT_ri, JSGT_rr, JU...
    printOperand(MI, 1, O); 
    break;
  case 2:
    // LDB, LDD, LDH, LDW, XADD32, XADD64
    printMemOperand(MI, 1, O); 
    break;
  case 3:
    // LD_imm64
    printImm64Operand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 16) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // JEQ_ri, JEQ_rr, JNE_ri, JNE_rr, JSGE_ri, JSGE_rr, JSGT_ri, JSGT_rr, JU...
    O << " goto "; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 1:
    // LDB, LDD, LDH, LDW, MOV_ri, MOV_rr
    return;
    break;
  case 2:
    // LD_pseudo, XADD32, XADD64
    O << ", "; 
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 18) & 1) {
    // XADD32, XADD64
    printOperand(MI, 3, O); 
    return;
  } else {
    // LD_pseudo
    printImm64Operand(MI, 2, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *BPFInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 13 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '0', 0,
  /* 7 */ 'r', '1', '1', 0,
  /* 11 */ 'r', '1', 0,
  /* 14 */ 'r', '2', 0,
  /* 17 */ 'r', '3', 0,
  /* 20 */ 'r', '4', 0,
  /* 23 */ 'r', '5', 0,
  /* 26 */ 'r', '6', 0,
  /* 29 */ 'r', '7', 0,
  /* 32 */ 'r', '8', 0,
  /* 35 */ 'r', '9', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    4, 11, 14, 17, 20, 23, 26, 29, 32, 35, 0, 7, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool BPFInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
